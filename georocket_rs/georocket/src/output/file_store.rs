use std::{
    collections::HashMap,
    io::ErrorKind,
    path::{Path, PathBuf},
};

use tokio::io::AsyncWriteExt;
use tokio::{fs::File, io::AsyncReadExt};
use uuid::Uuid;

use crate::input::Chunk;

// TODO: Create an appropriate type that can store the metadata information generated by the
// Indexers

type ID = Uuid;

/// The `FileStore` receives raw chunks and metadata for indexing through the respective
/// channels.
pub struct FileStore {
    directory: PathBuf,
    raw_rec: tokio::sync::mpsc::Receiver<(usize, Vec<u8>)>,
    chunk_rec: tokio::sync::mpsc::Receiver<(usize, Chunk)>,
    /// maps the internel indices of received chunks and metadata to
    /// the generated UUID which identifies the file location.
    index_map: std::collections::HashMap<usize, ID>,
    index_file: tokio::io::BufWriter<tokio::fs::File>,
}

struct Index {}

type IndexData = (usize, ());

impl FileStore {
    /// Creates a `FileStore` in the specified directory
    pub async fn new(
        directory: PathBuf,
        raw_rec: tokio::sync::mpsc::Receiver<(usize, Vec<u8>)>,
        chunk_rec: tokio::sync::mpsc::Receiver<(usize, Chunk)>,
    ) -> anyhow::Result<Self> {
        let index_path = Path::join(&directory, "index.geo");
        let index_file = tokio::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(index_path)
            .await?;
        let index_file = tokio::io::BufWriter::new(index_file);
        Ok(Self {
            directory,
            raw_rec,
            chunk_rec,
            index_file,
            index_map: HashMap::new(),
        })
    }

    pub async fn run(mut self) -> anyhow::Result<usize> {
        let mut count = 0;
        while let Some(raw) = self.raw_rec.recv().await {
            count += 1;
            let mut path = self.directory.clone();
            path.push(count.to_string());
            let mut file = tokio::fs::File::create(path).await?;
            file.write_all(&raw[..]).await?;
        }
        self.index_file.flush().await?;
        Ok(count)
    }
}
