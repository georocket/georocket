use lalrpop_util::{ParseError};

use crate::index::Value;
use super::{and, eq, gt, gte, lt, lte, not, or, Logical, Query, QueryPart};
use super::unescape::{unescape_identifier, unescape_string};
use super::error::QueryParserError;

grammar;

extern {
    type Error = QueryParserError;
}

pub Query: Query = {
    <a:Or> => a.into(),
};

Or: QueryPart = {
    <l:Or> r"(?i)\sor\s|\|\|" <r:And> => {
        match l {
            QueryPart::Logical(Logical::Or(mut parts)) => {
                parts.push(r);
                QueryPart::Logical(Logical::Or(parts))
            }
            _ => or![l, r],
        }
    },
    And,
};

And: QueryPart = {
    <l:And> r"(?i)\sand\s|&&" <r:Comparison> => {
        match l {
            QueryPart::Logical(Logical::And(mut parts)) => {
                parts.push(r);
                QueryPart::Logical(Logical::And(parts))
            }
            _ => and![l, r],
        }
    },
    Comparison,
};

Comparison: QueryPart = {
    <id:Identifier> r"![=]{1,2}" <l:Literal> => not![eq![id, l]],
    <id:Identifier> r"[=]{1,2}" <l:Literal> => eq![id, l],
    <id:Identifier> ">=" <l:Literal> => gte![id, l],
    <id:Identifier> ">" <l:Literal> => gt![id, l],
    <id:Identifier> "<=" <l:Literal> => lte![id, l],
    <id:Identifier> "<" <l:Literal> => lt![id, l],
    Logical,
}

Logical: QueryPart = {
    r"!\s*\(" <qp:Or> ")" => QueryPart::Logical(Logical::Not(Box::new(qp))),
    "(" <qp:Or> ")" => qp,
    <l:Literal> => l.into(),
}

Literal: Value = {
    String,
    Number,
};

Identifier: String = {
    PlainIdentifier,
    QuotedIdentifier,
};

String: Value = {
    <start:@L> <s:r#""([^"\\]|\\.)*""#> =>? unescape_string(&s[1..s.len() - 1], start + 1).map(|s| s.into()),
};

QuotedIdentifier: String = {
    <start:@L> <s:r#"`([^`\\]|\\.)*`"#> =>? unescape_identifier(&s[1..s.len() - 1], start + 1).map(|s| s.to_string()),
};

Number: Value = {
    <start:@L> <n:r"-?(\d+|(\d+\.\d*)|(\d*\.\d+))([eE][+-]?\d*)?"> <end:@R> =>? {
        n.parse::<i64>()
            .map(|i| Value::from(i))
            .or_else(|_| n.parse::<f64>().map(|i| i.into()))
            .map_err(|e| ParseError::User {
                error: QueryParserError::InvalidNumber { start, end },
            })
    }
};

PlainIdentifier: String = {
    <i:r"[_\p{L}][_\p{L}\d-]*"> => i.to_string(),
};
